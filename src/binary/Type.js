// Generated by CoffeeScript 1.8.0
(function() {
  var Data, Field, ReadState, Type, ioton, types,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  types = require('./Types');

  ioton = require('../ioton');

  module.exports = Type = (function() {
    function Type(schema) {
      if (typeof schema === 'string') {
        if (__indexOf.call(Type.TYPE, schema) >= 0 && schema !== Type.TYPE.ARRAY && schema !== Type.TYPE.OBJECT) {
          throw new TypeError('Unknown basic type: ' + schema);
        }
        this.type = schema;
      } else if (Array.isArray(schema)) {
        if (schema.length !== 1) {
          throw new TypeError('Invalid array type, it must have exactly one element');
        }
        this.type = Type.TYPE.ARRAY;
        this.subType = new Type(schema[0]);
      } else {
        if (!schema || typeof schema !== 'object') {
          throw new TypeError('Invalid type: ' + schema);
        }
        this.type = Type.TYPE.OBJECT;
        this.fields = Object.keys(schema).map(function(name) {
          if (typeof name === 'object') {
            return new Field(name.type, schema[name.type]);
          } else {
            return new Field(name, schema[name]);
          }
        });
      }
    }

    Type.prototype.types = types;

    Type.prototype.stringify = function(value) {
      var IOTON;
      IOTON = new ioton();
      return ioton.stringify(value);
    };

    Type.prototype.parse = function(buffer) {};

    Type.prototype.encode = function(value) {
      var data;
      data = new Data;
      this.write(value, data, '');
      return data.toBuffer();
    };

    Type.prototype.decode = function(buffer) {
      return this.read(new ReadState(buffer));
    };

    Type.prototype.write = function(value, data, path) {
      var field, i, len, subValue, subpath, _i, _ref, _results;
      if (this.type === Type.TYPE.ARRAY) {
        return this._writeArray(value, data, path, this.subType);
      } else if (this.type !== Type.TYPE.OBJECT) {
        return types[this.type].write(value, data, path);
      }
      if (!value || typeof value !== 'object') {
        throw new TypeError('Expected an object at ' + path);
      }
      i = 0;
      _results = [];
      for (len = _i = 0, _ref = this.fields.length; 0 <= _ref ? _i < _ref : _i > _ref; len = 0 <= _ref ? ++_i : --_i) {
        field = this.fields[i++];
        subpath = path ? path + '.' + field.name : field.name;
        subValue = value[field.name];
        if (field.optional) {
          if (subValue === void 0 || subValue === null) {
            types.boolean.write(false, data);
            continue;
          } else {
            types.boolean.write(true, data);
          }
        }
        if (!field.array) {
          field.type.write(subValue, data, subpath);
          continue;
        }
        _results.push(this._writeArray(subValue, data, subpath, field.type));
      }
      return _results;
    };

    Type.prototype._writeArray = function(value, data, path, type) {
      var i, len, _i, _results;
      if (!Array.isArray(value)) {
        throw new TypeError('Expected an Array at ' + path);
      }
      len = value.length;
      types.uint.write(len, data);
      _results = [];
      for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
        _results.push(type.write(value[i], data, path + '.' + i));
      }
      return _results;
    };

    Type.prototype.read = function(state) {
      this.read = this._compileRead();
      return this.read(state);
    };

    Type.prototype.getHash = function() {
      var hash, hashType;
      hash = new Data;
      hashType(this, false, false);
      return hash.toBuffer();
      return hashType = function(type, array, optional) {
        hash.writeUInt8((type.type.charCodeAt(0) & 0x3f) | (array ? 0x80 : 0) | (optional ? 0x40 : 0));
        if (type.type === Type.TYPE.ARRAY) {
          return hashType(type.subType, false, false);
        } else if (type.type === Type.TYPE.OBJECT) {
          types.uint.write(type.fields.length, hash);
          return type.fields.forEach(function(field) {
            return hashType(field.type, field.array, field.optional);
          });
        }
      };
    };

    Type.prototype._compileRead = function() {
      var code;
      if (this.type !== Type.TYPE.OBJECT && this.type !== Type.TYPE.ARRAY) {
        return types[this.type].read;
      } else if (this.type === Type.TYPE.ARRAY) {
        return this._readArray.bind(this, this.subType);
      }
      code = 'return {' + this.fields.map(function(field, i) {
        var fieldStr, name, readCode;
        name = JSON.stringify(field.name);
        fieldStr = 'this.fields[' + i + ']';
        if (field.array) {
          readCode = 'this._readArray(' + fieldStr + '.type, state)';
        } else {
          readCode = fieldStr + '.type.read(state)';
        }
        if (!field.optional) {
          code = name + ': ' + readCode;
        } else {
          code = name + ': this.types.boolean.read(state) ? ' + readCode + ' : undefined';
        }
        return code;
      }).join(',') + '}';
      return new Function('state', code);
    };

    Type.prototype._readArray = function(type, state) {
      var arr, j, _i, _ref;
      arr = new Array(types.uint.read(state));
      for (j = _i = 0, _ref = arr.length; 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
        arr[j] = type.read(state);
      }
      return arr;
    };

    return Type;

  })();

  Data = require('./Data');

  ReadState = require('./ReadState');

  Field = require('./Field');

  Type.TYPE = {
    UINT: 'uint',
    INT: 'int',
    FLOAT: 'float',
    NUMBER: 'float',
    STRING: 'string',
    BUFFER: 'Buffer',
    BOOLEAN: 'boolean',
    JSON: 'json',
    OID: 'oid',
    REGEX: 'regex',
    DATE: 'date',
    ARRAY: '[array]',
    OBJECT: 'object'
  };

}).call(this);

//# sourceMappingURL=Type.js.map
