// Generated by CoffeeScript 1.8.0
(function() {
  var IOTON, Stack,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Stack = require('stackjs');

  module.exports = IOTON = (function() {
    var convertToJavascript, number, sanatize, unreserve;

    function IOTON(encoding) {
      var k, v, _ref;
      if (encoding == null) {
        encoding = "ascii";
      }
      this.convertToString = __bind(this.convertToString, this);
      this.encoding = encoding;
      this.separatorCharacters = {
        skip0: '\x1F'
      };
      this.separators = [];
      this.separators[0] = this.separatorCharacters.skip0.charCodeAt(0);
      this.containerCharacters = {
        objectBegin: '\x01',
        objectEnd: '\x04',
        arrayBegin: '\x02',
        arrayEnd: '\x03'
      };
      this.containers = [];
      _ref = this.containerCharacters;
      for (k in _ref) {
        v = _ref[k];
        this.containers.push(v);
      }
      this.nullCharacter = '\x19';
      this.quoteCharacter = '\x0F';
      this.nullHextet = 0x19;
      this.quoteHextet = 0x0F;
      this.trueHextet = 0x54;
      this.falseHextet = 0x46;
    }

    IOTON.prototype.reset = function() {
      return true;
    };

    IOTON.prototype.stringify = function(value) {
      var stringUTF8;
      stringUTF8 = this.convertToString(value);
      return new Buffer(stringUTF8, this.encoding);
    };

    IOTON.prototype.convertToString = function(value) {
      var enclosures, k, partial, v, _i, _len;
      if (value === null || value === void 0) {
        return this.nullCharacter;
      }
      switch (typeof value) {
        case 'number':
          return value.toString();
        case 'boolean':
          if (value) {
            return "T";
          } else {
            return "F";
          }
          break;
        case 'string':
          return this.quoteCharacter + unreserve(value);
        case 'object':
          partial = [];
          if (value instanceof Array) {
            for (_i = 0, _len = value.length; _i < _len; _i++) {
              v = value[_i];
              partial.push(this.convertToString(v));
            }
            enclosures = {
              start: this.containerCharacters.arrayBegin,
              stop: this.containerCharacters.arrayEnd
            };
          } else {
            for (k in value) {
              v = value[k];
              partial.push(this.convertToString(v));
            }
            enclosures = {
              start: this.containerCharacters.objectBegin,
              stop: this.containerCharacters.objectEnd
            };
          }
          return enclosures.start + partial.join(this.separatorCharacters.skip0) + enclosures.stop;
        default:
          return String(value);
      }
    };

    IOTON.prototype.parse = function(text, schema) {
      var end, falseHextet, findEnd, i, indexStack, j, makeArrayValue, makeBoolean, makeContainerValueInArray, makeContainerValueInObject, makeObjectValue, makeString, makeTyped, makeValue, nullHextet, objects, pop, push, quoteHextet, separator, set, setArray, setObject, split, splitCharacter, stack, start, token, tokens, top, trueHextet, _i, _len, _ref, _ref1, _ref2;
      stack = new Stack();
      indexStack = new Stack();
      splitCharacter = this.separatorCharacters.skip0;
      quoteHextet = this.quoteHextet;
      trueHextet = this.trueHextet;
      falseHextet = this.falseHextet;
      nullHextet = this.nullHextet;
      split = function(buffer, characters) {
        var i, separator, tempBuffer, tempString, tokens, _i, _ref, _ref1;
        tokens = [];
        separator = splitCharacter;
        tempString = "" + separator;
        for (i = _i = 0, _ref = buffer.length; _i < _ref; i = _i += 1) {
          if ((_ref1 = buffer[i], __indexOf.call(characters, _ref1) >= 0)) {
            tempBuffer = new Buffer(tempString, this.encoding);
            tokens.push(tempBuffer);
            separator = String.fromCharCode(buffer[i]);
            tempString = "" + separator;
          } else {
            tempString += String.fromCharCode(buffer[i]);
          }
        }
        tempBuffer = new Buffer(tempString, this.encoding);
        tokens.push(tempBuffer);
        return tokens;
      };
      push = function(value, type, index) {
        var keys;
        if (index == null) {
          index = null;
        }
        keys = null;
        if (indexStack.isEmpty()) {
          keys = schema;
        } else {
          if (type === "object") {
            keys = (stack.peek().schema)[(indexStack.peek()) * 2 + 1];
          } else {
            if ((indexStack.peek()) * 2 + 1 < stack.peek().schema.length) {
              keys = stack.peek().schema[(indexStack.peek()) * 2 + 1];
            } else {
              keys = stack.peek().schema;
            }
            if (typeof keys === "string") {
              keys = stack.peek().schema;
            }
          }
        }
        indexStack.push(index);
        return stack.push({
          value: value,
          type: type,
          schema: keys
        });
      };
      pop = function() {
        var top;
        top = stack.pop();
        indexStack.pop();
        return top;
      };
      makeBoolean = function(value) {
        switch (value[0]) {
          case trueHextet:
            return true;
          case falseHextet:
            return false;
          default:
            return null;
        }
      };
      makeString = function(value) {
        if (value[0] === quoteHextet) {
          return value.toString().substring(1);
        }
        return value.toString();
      };
      makeTyped = function(value) {
        switch (value[0]) {
          case nullHextet:
            return null;
          case trueHextet:
          case falseHextet:
            return makeBoolean(value);
          case quoteHextet:
            return makeString(value);
          default:
            return number(value);
        }
      };
      makeValue = function(value, type, tag) {
        if (value[0] === nullHextet) {
          return null;
        }
        switch (type) {
          case "string":
            return makeString(value);
          case "number":
            return number(value);
          case "boolean":
            return makeBoolean(value);
          case "typed":
            return makeTyped(value);
          default:
            return makeTyped(value);
        }
      };
      makeContainerValueInObject = function(value) {
        var index, tag, type;
        index = indexStack.pop();
        tag = stack.peek().schema[index * 2];
        type = stack.peek().schema[index * 2 + 1];
        index++;
        stack.peek().value[tag] = value;
        return indexStack.push(index);
      };
      makeObjectValue = function(value) {
        var index, tag, type;
        if (value == null) {
          value = null;
        }
        index = indexStack.pop();
        tag = stack.peek().schema[index * 2];
        type = stack.peek().schema[index * 2 + 1];
        index++;
        value = makeValue(value, type, tag);
        stack.peek().value[tag] = value;
        return indexStack.push(index);
      };
      setObject = function(value, separator) {
        if (!(value instanceof Buffer) && (typeof value === 'array' || typeof value === 'object')) {
          return makeContainerValueInObject(value);
        } else {
          return makeObjectValue(value);
        }
      };
      makeContainerValueInArray = function(value) {
        var tag, type;
        tag = stack.peek().schema[0];
        type = stack.peek().schema[1];
        return stack.peek().value.push(value);
      };
      makeArrayValue = function(value) {
        var tag, type;
        tag = stack.peek().schema[0];
        type = stack.peek().schema[1];
        if (tag !== "") {
          console.log("have tag in array! : " + tag + "  from: " + stack.peek().schema);
        }
        value = makeValue(value, type, tag);
        return stack.peek().value.push(value);
      };
      setArray = function(value, separator) {
        if (!(value instanceof Buffer) && (typeof value === 'array' || typeof value === 'object')) {
          return makeContainerValueInArray(value);
        } else {
          return makeArrayValue(value);
        }
      };
      set = function(value) {
        var top;
        if (!stack.isEmpty()) {
          top = stack.peek();
          if (top.type === "object") {
            return setObject(value, null);
          } else {
            return setArray(value, null);
          }
        }
      };
      findEnd = (function(_this) {
        return function(token, i) {
          var j;
          j = i;
          while (i < token.length && token[i] !== _this.containerCharacters.arrayEnd.charCodeAt(0) && token[i] !== _this.containerCharacters.objectEnd.charCodeAt(0)) {
            i++;
          }
          return [j, i - 1, i];
        };
      })(this);
      objects = null;
      tokens = split(text, this.separators);
      if (tokens[1] === void 0) {
        return makeTyped(text);
      }
      j = 0;
      for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        i = 0;
        while (i < token.length) {
          if (_ref = token[i], __indexOf.call(this.separators, _ref) >= 0) {
            separator = token[i];
            i++;
          }
          if (token[i] === this.containerCharacters.objectBegin.charCodeAt(0)) {
            push({}, "object", 0, {});
            i++;
          } else if (token[i] === this.containerCharacters.objectEnd.charCodeAt(0)) {
            top = pop();
            objects = top.value;
            set(objects);
            i++;
          } else if (token[i] === this.containerCharacters.arrayBegin.charCodeAt(0)) {
            push([], "array", 0, []);
            i++;
          } else if (token[i] === this.containerCharacters.arrayEnd.charCodeAt(0)) {
            top = pop();
            objects = top.value;
            set(objects);
            i++;
          } else {
            top = stack.peek();
            if (top.type === "object") {
              _ref1 = findEnd(token, i), start = _ref1[0], end = _ref1[1], i = _ref1[2];
              setObject(token.slice(start, +end + 1 || 9e9), separator);
            } else {
              _ref2 = findEnd(token, i), start = _ref2[0], end = _ref2[1], i = _ref2[2];
              setArray(token.slice(start, +end + 1 || 9e9), separator);
            }
          }
        }
      }
      return objects;
    };

    convertToJavascript = function(text) {
      var obj;
      obj = eval('(' + sanatize(text.toString()) + ')');
      return obj;
    };

    IOTON.prototype.JSON = function(value, schema) {
      if (schema) {
        return this.uncontrol(value);
      } else {
        return this.uncontrol(value);
      }
    };

    IOTON.prototype.IOTON = function(value) {
      return value;
    };

    unreserve = function(text) {
      return text.replace(/[\u0000-\u0006|\u000E-\u0010|\u0012|\u0014-\u001A|\u001C-\u001F]/g, '');
    };

    sanatize = function(text) {
      return text;
    };

    IOTON.prototype.uncontrol = function(ioton) {
      var i, text, _i, _ref;
      text = new Buffer(ioton);
      for (i = _i = 0, _ref = text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (text[i] === 0x01) {
          text[i] = 0x7B;
        } else if (text[i] === 0x02) {
          text[i] = 0x5B;
        } else if (text[i] === 0x03) {
          text[i] = 0x5D;
        } else if (text[i] === 0x04) {
          text[i] = 0x7D;
        } else if (text[i] === 0x0E) {
          text[i] = 0x7D;
        } else if (text[i] === 0x0F) {
          text[i] = 0x22;
        } else if (text[i] === 0x1A) {
          text[i] = 0x2C;
        } else if (text[i] === 0x1C) {
          text[i] = 0x2C;
        } else if (text[i] === 0x1D) {
          text[i] = 0x2C;
        } else if (text[i] === 0x1E) {
          text[i] = 0x2C;
        } else if (text[i] === 0x1F) {
          text[i] = 0x2C;
        } else if (text[i] === 0x19) {
          text[i] = 0x40;
        }
      }
      return String(text);
    };

    number = function(value) {
      return parseInt(value.toString());
    };

    return IOTON;

  })();

}).call(this);

//# sourceMappingURL=ioton.js.map
