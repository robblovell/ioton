// Generated by CoffeeScript 1.8.0
(function() {
  var IOTON, Stack;

  Stack = require('stackjs');

  module.exports = IOTON = (function() {
    var convertToJavascript, convertToString, number, objectify, runLengthEncode, sanatize, separators, unreserve;

    function IOTON(rle, encoding) {
      if (rle == null) {
        rle = false;
      }
      if (encoding == null) {
        encoding = "ascii";
      }
      this.encoding = encoding;
      this.rle = rle;
      this.lastValue = void 0;
    }

    separators = {
      skip0: '\x1F',
      skip: ['\x1E', '\x1D', '\x1C'],
      skipN: '\x1A'
    };

    IOTON.prototype.reset = function() {
      return this.lastValue = void 0;
    };

    IOTON.prototype.stringify = function(value) {
      var stringUTF8;
      stringUTF8 = convertToString(value, this.lastValue, true);
      this.lastValue = value;
      return new Buffer(stringUTF8, this.encoding);
    };

    runLengthEncode = function(partials, enclosures, rle) {
      var encoded, i, skip, value, _i, _len;
      if (!rle) {
        return enclosures.start + partials.join(separators.skip0) + enclosures.stop;
      } else {
        encoded = enclosures.start;
        skip = -1;
        for (i = _i = 0, _len = partials.length; _i < _len; i = ++_i) {
          value = partials[i];
          if (value === '\x10') {
            skip++;
          } else {
            if (skip === -1) {
              encoded += (i !== 0 ? separators.skip0 : "") + value;
            } else if (skip <= 2) {
              encoded += separators.skip[skip] + value;
            } else {
              encoded += separators.skipN + skip.toString() + separators.skip0 + value;
            }
            skip = -1;
          }
        }
        if (skip !== -1) {
          if (skip <= 2) {
            encoded += separators.skip[skip];
          } else {
            encoded += separators.skipN + skip.toString() + separators.skip0;
          }
        }
        return encoded + enclosures.stop;
      }
    };

    convertToString = function(value, lastValue, rle) {
      var enclosures, i, k, partial, v, _i, _j, _len, _len1;
      if (rle && lastValue !== void 0 && value === lastValue) {
        return '\x10';
      }
      if (value === null || value === void 0) {
        return '\x19';
      }
      switch (typeof value) {
        case 'number':
          return value.toString();
        case 'boolean':
          if (value) {
            return "T";
          } else {
            return "F";
          }
          break;
        case 'string':
          return '\x0F' + unreserve(value);
        case 'object':
          partial = [];
          if (value instanceof Array) {
            if ((lastValue != null) && rle) {
              for (i = _i = 0, _len = value.length; _i < _len; i = ++_i) {
                v = value[i];
                partial.push(convertToString(v, lastValue[i], rle));
              }
            } else {
              for (_j = 0, _len1 = value.length; _j < _len1; _j++) {
                v = value[_j];
                partial.push(convertToString(v, void 0, rle));
              }
            }
            enclosures = {
              start: '\x02',
              stop: '\x03'
            };
          } else {
            if ((lastValue != null) && rle) {
              for (k in value) {
                v = value[k];
                partial.push(convertToString(v, lastValue[k], rle));
              }
            } else {
              for (k in value) {
                v = value[k];
                partial.push(convertToString(v, void 0, rle));
              }
            }
            enclosures = {
              start: '\x01',
              stop: '\x04'
            };
          }
          return runLengthEncode(partial, enclosures, rle);
        default:
          return String(value);
      }
    };

    IOTON.prototype.parse = function(buffer, schema) {
      var objects;
      objects = objectify(buffer, schema);
      return objects;
    };

    objectify = function(text, schema) {
      var end, findEnd, i, indexStack, j, makeBoolean, makeString, makeTyped, makeValue, na, objects, pop, push, set, setArray, setObject, split, stack, start, token, tokens, type, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
      stack = new Stack();
      indexStack = new Stack();
      split = function(buffer, character) {
        var i, tempBuffer, tempString, tokens, _i, _ref;
        tokens = [];
        tempString = "";
        for (i = _i = 0, _ref = buffer.length; _i < _ref; i = _i += 1) {
          if (buffer[i] === character) {
            tempBuffer = new Buffer(tempString, this.encoding);
            tokens.push(tempBuffer);
            tempString = "";
          } else {
            tempString += String.fromCharCode(buffer[i]);
          }
        }
        tempBuffer = new Buffer(tempString, this.encoding);
        tokens.push(tempBuffer);
        return tokens;
      };
      push = function(value, type, index) {
        var keys;
        if (index == null) {
          index = null;
        }
        keys = null;
        if (indexStack.isEmpty()) {
          keys = schema;
        } else {
          if (type === "object") {
            keys = (stack.peek()[2])[(indexStack.peek()) * 2 + 1];
          } else {
            if ((indexStack.peek()) * 2 + 1 < (stack.peek()[2]).length) {
              keys = (stack.peek()[2])[(indexStack.peek()) * 2 + 1];
            } else {
              keys = stack.peek()[2];
            }
            if (typeof keys === "string") {
              keys = stack.peek()[2];
            }
          }
        }
        indexStack.push(index);
        return stack.push([value, type, keys]);
      };
      pop = function() {
        var top;
        top = stack.pop();
        indexStack.pop();
        return top;
      };
      makeBoolean = function(value) {
        switch (value[0]) {
          case 0x54:
            return true;
          case 0x46:
            return false;
          default:
            return null;
        }
      };
      makeString = function(value) {
        if (value[0] === 0x0F) {
          return value.toString().substring(1);
        }
        return value.toString();
      };
      makeTyped = function(value) {
        switch (value[0]) {
          case 0x46:
          case 0x54:
            return makeBoolean(value);
          case 0x0F:
            return makeString(value);
          default:
            return number(value);
        }
      };
      makeValue = function(value, type, tag) {
        if (value[0] === 0x19) {
          return null;
        }
        switch (type) {
          case "string":
            return makeString(value);
          case "number":
            return number(value);
          case "boolean":
            return makeBoolean(value);
          case "typed":
            return makeTyped(value);
          default:
            return makeTyped(value);
        }
      };
      setObject = function(value) {
        var index, tag, type;
        index = indexStack.pop();
        tag = stack.peek()[2][index * 2];
        type = stack.peek()[2][index * 2 + 1];
        index++;
        if (!(value instanceof Buffer) && (typeof value === 'array' || typeof value === 'object')) {
          stack.peek()[0][tag] = value;
        } else {
          value = makeValue(value, type, tag);
          stack.peek()[0][tag] = value;
        }
        return indexStack.push(index);
      };
      setArray = function(value) {
        var tag, type;
        tag = stack.peek()[2][0];
        type = stack.peek()[2][1];
        if (tag !== "") {
          console.log("have tag in array! : " + tag + "  from: " + stack.peek()[2]);
        }
        if (!(value instanceof Buffer) && (typeof value === 'array' || typeof value === 'object')) {
          return stack.peek()[0].push(value);
        } else {
          value = makeValue(value, type, tag);
          return stack.peek()[0].push(value);
        }
      };
      set = function(value) {
        var na, type, _ref;
        if (!stack.isEmpty()) {
          _ref = stack.peek(), na = _ref[0], type = _ref[1];
          if (type === "object") {
            return setObject(value);
          } else {
            return setArray(value);
          }
        }
      };
      findEnd = function(token, i) {
        var j;
        j = i;
        while (i < token.length && token[i] !== 0x03 && token[i] !== 0x04) {
          i++;
        }
        return [j, i - 1, i];
      };
      objects = null;
      tokens = split(text, 0x1F);
      j = 0;
      for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        i = 0;
        while (i < token.length) {
          if (token[i] === 0x01) {
            push({}, "object", 0);
            i++;
          } else if (token[i] === 0x04) {
            _ref = pop(), objects = _ref[0], na = _ref[1], na = _ref[2];
            set(objects);
            i++;
          } else if (token[i] === 0x02) {
            push([], "array", 0);
            i++;
          } else if (token[i] === 0x03) {
            _ref1 = pop(), objects = _ref1[0], na = _ref1[1], na = _ref1[2];
            set(objects);
            i++;
          } else {
            _ref2 = stack.peek(), na = _ref2[0], type = _ref2[1];
            if (type === "object") {
              _ref3 = findEnd(token, i), start = _ref3[0], end = _ref3[1], i = _ref3[2];
              setObject(token.slice(start, +end + 1 || 9e9));
            } else {
              _ref4 = findEnd(token, i), start = _ref4[0], end = _ref4[1], i = _ref4[2];
              setArray(token.slice(start, +end + 1 || 9e9));
            }
          }
        }
      }
      return objects;
    };

    convertToJavascript = function(text) {
      var obj;
      console.log(text.toString());
      obj = eval('(' + sanatize(text.toString()) + ')');
      return obj;
    };

    IOTON.prototype.JSON = function(value, schema) {
      if (schema) {
        return this.uncontrol(value);
      } else {
        return this.uncontrol(value);
      }
    };

    IOTON.prototype.IOTON = function(value) {
      return value;
    };

    unreserve = function(text) {
      return text.replace(/[\u0000-\u0006|\u000E-\u0010|\u0012|\u0014-\u001A|\u001C-\u001F]/g, '');
    };

    sanatize = function(text) {
      return text;
    };

    IOTON.prototype.uncontrol = function(ioton) {
      var i, text, _i, _ref;
      text = new Buffer(ioton);
      for (i = _i = 0, _ref = text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (text[i] === 0x01) {
          text[i] = 0x7B;
        } else if (text[i] === 0x02) {
          text[i] = 0x5B;
        } else if (text[i] === 0x03) {
          text[i] = 0x5D;
        } else if (text[i] === 0x04) {
          text[i] = 0x7D;
        } else if (text[i] === 0x0E) {
          text[i] = 0x7D;
        } else if (text[i] === 0x0F) {
          text[i] = 0x22;
        } else if (text[i] === 0x1A) {
          text[i] = 0x2C;
        } else if (text[i] === 0x1C) {
          text[i] = 0x2C;
        } else if (text[i] === 0x1D) {
          text[i] = 0x2C;
        } else if (text[i] === 0x1E) {
          text[i] = 0x2C;
        } else if (text[i] === 0x1F) {
          text[i] = 0x2C;
        } else if (text[i] === 0x19) {
          text[i] = 0x40;
        }
      }
      return String(text);
    };

    number = function(value) {
      return parseInt(value.toString());
    };

    return IOTON;

  })();

}).call(this);

//# sourceMappingURL=ioton.js.map
