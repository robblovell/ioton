// Generated by CoffeeScript 1.8.0
(function() {
  var IOTON, Stack;

  Stack = require('stackjs');

  module.exports = IOTON = (function() {
    var convertToJavascript, convertToString, number, objectify, objectifyStr, sanatize, unreserve;

    function IOTON(encoding) {
      if (encoding == null) {
        encoding = "ascii";
      }
      this.encoding = encoding;
      this.meta = {
        '\x00': '',
        '\x01': '',
        '\x02': '',
        '\x03': '',
        '\x04': '',
        '\x05': '',
        '\x06': '',
        '\x10': '',
        '\x17': '',
        '\x19': '',
        '\x1A': '',
        '\x1B': '',
        '\x1C': '',
        '\x1D': '',
        '\x1E': '',
        '\x1F': ''
      };
      this.schema = null;
    }

    IOTON.prototype.stringify = function(value) {
      var stringUTF8;
      stringUTF8 = convertToString(value);
      return new Buffer(stringUTF8, this.encoding);
    };

    convertToString = function(value) {
      var k, partial, v, _i, _len;
      if (value && typeof value === 'object' && typeof value.toIOTON === 'function') {
        return value.toIOTON(key);
      }
      if (value === void 0) {
        return '\x19';
      }
      if (value === null) {
        return '\x0E';
      }
      switch (typeof value) {
        case 'number':
          return number(value);
        case 'boolean':
          if (value) {
            return "T";
          } else {
            return "F";
          }
          break;
        case 'string':
          return '\x0F' + unreserve(value);
        case 'object':
          if (!value) {
            return 'null';
          }
          partial = [];
          if (value instanceof Array) {
            for (_i = 0, _len = value.length; _i < _len; _i++) {
              v = value[_i];
              partial.push(convertToString(v));
            }
            return '\x02' + partial.join('\x1F') + '\x03';
          } else {
            for (k in value) {
              v = value[k];
              partial.push(convertToString(v));
            }
            return '\x01' + partial.join('\x1F') + '\x04';
          }
          break;
        default:
          return String(value);
      }
    };

    IOTON.prototype.parse = function(buffer, schema) {
      var objects, text;
      text = new Buffer(buffer);
      text = this.uncontrol(text);
      objects = objectify(buffer, schema);
      return objects;
    };

    objectifyStr = function(text) {
      var end, findEnd, i, index, indexStack, j, na, objects, pop, push, set, setArray, setObject, stack, start, token, tokens, type, _i, _len, _ref, _ref1, _ref2, _ref3;
      stack = new Stack();
      indexStack = new Stack();
      push = function(value, type, index) {
        if (index == null) {
          index = null;
        }
        stack.push([value, type]);
        if ((index != null)) {
          return indexStack.push(index);
        }
      };
      pop = function() {
        var na, value, _ref;
        _ref = stack.pop(), value = _ref[0], na = _ref[1], na = _ref[2];
        indexStack.pop();
        return value;
      };
      setObject = function(value) {
        var index, na, schema, _ref;
        index = indexStack.pop();
        _ref = stack.peek(), na = _ref[0], na = _ref[1], schema = _ref[2];
        stack.peek()[0][index++] = value;
        return indexStack.push(index);
      };
      setArray = function(value) {
        return stack.peek()[0].push(value);
      };
      set = function(value) {
        var na, type, _ref;
        if (!stack.isEmpty()) {
          _ref = stack.peek(), na = _ref[0], type = _ref[1];
          if (type === "object") {
            return setObject(value);
          } else {
            return setArray(value);
          }
        }
      };
      findEnd = function(token, i) {
        var j;
        j = i;
        while (i < token.length && token[i] !== '}' && token[i] !== ']') {
          i++;
        }
        return [j, i - 1, i];
      };
      objects = null;
      tokens = text.split(',');
      j = 0;
      index = 0;
      for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        i = 0;
        while (i < token.length) {
          if (token[i] === '{') {
            push({}, "object", 0);
            i++;
          } else if (token[i] === '}') {
            objects = pop();
            set(objects);
            i++;
          } else if (token[i] === '[') {
            push([], "array");
            i++;
          } else if (token[i] === ']') {
            _ref = stack.pop(), objects = _ref[0], na = _ref[1];
            set(objects);
            i++;
          } else {
            _ref1 = stack.peek(), na = _ref1[0], type = _ref1[1];
            if (type === "object") {
              _ref2 = findEnd(token, i), start = _ref2[0], end = _ref2[1], i = _ref2[2];
              setObject(token.slice(start, +end + 1 || 9e9));
            } else {
              _ref3 = findEnd(token, i), start = _ref3[0], end = _ref3[1], i = _ref3[2];
              setArray(token.slice(start, +end + 1 || 9e9));
            }
          }
        }
      }
      return objects;
    };

    objectify = function(text, schema) {
      var end, findEnd, i, index, indexStack, j, keys, makeBoolean, makeTyped, makeValue, na, objects, pop, push, set, setArray, setObject, split, stack, start, token, tokens, type, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
      stack = new Stack();
      indexStack = new Stack();
      split = function(buffer, character) {
        var i, tempBuffer, tempString, tokens, _i, _ref;
        tokens = [];
        tempString = "";
        for (i = _i = 0, _ref = buffer.length; _i < _ref; i = _i += 1) {
          if (buffer[i] === character) {
            tempBuffer = new Buffer(tempString, this.encoding);
            tokens.push(tempBuffer);
            tempString = "";
          } else {
            tempString += String.fromCharCode(buffer[i]);
          }
        }
        tempBuffer = new Buffer(tempString, this.encoding);
        tokens.push(tempBuffer);
        return tokens;
      };
      push = function(value, type, index) {
        var keys;
        if (index == null) {
          index = null;
        }
        keys = null;
        if (indexStack.isEmpty()) {
          keys = schema;
        } else {
          if (type === "object") {
            keys = (stack.peek()[2])[(indexStack.peek()) * 2 + 1];
          } else {
            keys = (stack.peek()[2])[(indexStack.peek()) * 2 + 1];
          }
        }
        indexStack.push(index);
        return stack.push([value, type, keys]);
      };
      pop = function() {
        var top;
        top = stack.pop();
        indexStack.pop();
        return top;
      };
      makeBoolean = function(value) {
        switch (value[0]) {
          case 84:
            return true;
          case 70:
            return false;
          default:
            return null;
        }
      };
      makeTyped = function(value) {
        switch (value[0]) {
          case 78:
          case 84:
            return makeBoolean(value);
          case 15:
            return value.toString();
          default:
            return parseInt(value);
        }
      };
      makeValue = function(value, type, tag) {
        if (value[0] === 14) {
          return null;
        }
        if (value[0] === 25) {
          return void 0;
        }
        switch (type) {
          case "string":
            return value.toString().slice(1, -1);
          case "number":
            return parseInt(value);
          case "boolean":
            return makeBoolean(value);
          case "typed":
            return makeTyped(value);
          default:
            return makeTyped(value);
        }
      };
      setObject = function(value) {
        var index, tag, type;
        index = indexStack.pop();
        tag = stack.peek()[2][index * 2];
        type = stack.peek()[2][index * 2 + 1];
        index++;
        if (!(value instanceof Buffer) && (typeof value === 'array' || typeof value === 'object')) {
          stack.peek()[0][tag] = value;
        } else {
          value = makeValue(value, type, tag);
          stack.peek()[0][tag] = value;
        }
        return indexStack.push(index);
      };
      setArray = function(value) {
        var index, tag, type;
        index = indexStack.peek();
        tag = stack.peek()[2][0];
        type = stack.peek()[2][1];
        if (tag !== "") {
          console.log("have tag in array! : " + tag + "  from: " + stack.peek()[2]);
        }
        if (!(value instanceof Buffer) && (typeof value === 'array' || typeof value === 'object')) {
          return stack.peek()[0].push(value);
        } else {
          value = makeValue(value, type, tag);
          return stack.peek()[0].push(value);
        }
      };
      set = function(value) {
        var na, type, _ref;
        if (!stack.isEmpty()) {
          _ref = stack.peek(), na = _ref[0], type = _ref[1];
          if (type === "object") {
            return setObject(value);
          } else {
            return setArray(value);
          }
        }
      };
      findEnd = function(token, i) {
        var j;
        j = i;
        while (i < token.length && token[i] !== 0x03 && token[i] !== 0x04) {
          i++;
        }
        return [j, i - 1, i];
      };
      objects = null;
      tokens = split(text, 0x1F);
      j = 0;
      index = null;
      keys = null;
      for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        i = 0;
        while (i < token.length) {
          if (token[i] === 0x01) {
            push({}, "object", 0);
            i++;
          } else if (token[i] === 0x04) {
            _ref = pop(), objects = _ref[0], na = _ref[1], na = _ref[2];
            set(objects);
            i++;
          } else if (token[i] === 0x02) {
            push([], "array", 0);
            i++;
          } else if (token[i] === 0x03) {
            _ref1 = pop(), objects = _ref1[0], na = _ref1[1], na = _ref1[2];
            set(objects);
            i++;
          } else {
            _ref2 = stack.peek(), na = _ref2[0], type = _ref2[1];
            if (type === "object") {
              _ref3 = findEnd(token, i), start = _ref3[0], end = _ref3[1], i = _ref3[2];
              setObject(token.slice(start, +end + 1 || 9e9));
            } else {
              _ref4 = findEnd(token, i), start = _ref4[0], end = _ref4[1], i = _ref4[2];
              setArray(token.slice(start, +end + 1 || 9e9));
            }
          }
        }
      }
      return objects;
    };

    convertToJavascript = function(text) {
      var obj;
      console.log(text.toString());
      obj = eval('(' + sanatize(text.toString()) + ')');
      return obj;
    };

    IOTON.prototype.JSON = function(value, schema) {
      if (schema) {
        return this.uncontrol(value);
      } else {
        return this.uncontrol(value);
      }
    };

    IOTON.prototype.IOTON = function(value) {
      return value;
    };

    unreserve = function(text) {
      return text.replace(/[\u0000-\u0006|\u000E-\u0010|\u0012|\u0014-\u0017|\u0019-\u001A|\u001C-\u001F]/g, '');
    };

    sanatize = function(text) {
      return text;
    };

    IOTON.prototype.uncontrol = function(ioton) {
      var i, text, _i, _ref;
      text = new Buffer(ioton);
      for (i = _i = 0, _ref = text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (text[i] === 0x1) {
          text[i] = 123;
        }
        if (text[i] === 0x4) {
          text[i] = 125;
        }
        if (text[i] === 0x2) {
          text[i] = 91;
        }
        if (text[i] === 0x3) {
          text[i] = 93;
        }
        if (text[i] === 0x1F) {
          text[i] = 44;
        }
        if (text[i] === 0xF) {
          text[i] = 34;
        }
        if (text[i] === 0xE) {
          text[i] = 64;
        }
        if (text[i] === 0x19) {
          text[i] = 63;
        }
      }
      return String(text);
    };

    number = function(text) {
      return String(text);
    };

    return IOTON;

  })();

}).call(this);

//# sourceMappingURL=ioton.js.map
