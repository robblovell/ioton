// Generated by CoffeeScript 1.8.0
(function() {
  var IOTON, Stack, Type,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Stack = require('stackjs');

  Type = require('./binary/Type');

  module.exports = IOTON = (function() {
    var convertToJavascript, makeSchema, number, printSchema, sanatize, translate, unreserve;

    function IOTON(schema, encoding) {
      var k, v, _ref;
      if (schema == null) {
        schema = 'string';
      }
      if (encoding == null) {
        encoding = "ascii";
      }
      this.convertToString = __bind(this.convertToString, this);
      this.encoding = encoding;
      this.separatorCharacters = {
        skip0: '\x1F'
      };
      this.separators = [];
      this.separators[0] = this.separatorCharacters.skip0.charCodeAt(0);
      this.containerCharacters = {
        objectBegin: '\x01',
        objectEnd: '\x04',
        arrayBegin: '\x02',
        arrayEnd: '\x03'
      };
      this.containers = [];
      _ref = this.containerCharacters;
      for (k in _ref) {
        v = _ref[k];
        this.containers.push(v);
      }
      this.nullCharacter = '\x19';
      this.undefinedCharacter = '\x16';
      this.quoteCharacter = '\x0F';
      this.nullHextet = 0x19;
      this.undefinedHextet = 0x16;
      this.quoteHextet = 0x0F;
      this.trueHextet = 0x54;
      this.falseHextet = 0x46;
      this.schema(schema);
    }

    IOTON.prototype.schema = function(schema) {
      if (schema == null) {
        schema = null;
      }
      if (schema === null) {
        return this.schema;
      }
      this._type = new Type(schema);
      this.parser_schema = makeSchema(schema);
      this._schema = schema;
      return this._schema;
    };

    IOTON.prototype.reset = function() {
      return true;
    };

    IOTON.prototype.encode = function(object) {
      return this._type.encode(object);
    };

    IOTON.prototype.decode = function(buffer) {
      return this._type.decode(buffer);
    };

    IOTON.prototype.stringify = function(value) {
      var stringUTF8;
      stringUTF8 = this.convertToString(value);
      return new Buffer(stringUTF8, this.encoding);
    };

    IOTON.prototype.convertToString = function(value) {
      var enclosures, k, partial, v, _i, _len;
      if (value === null) {
        return this.nullCharacter;
      }
      if (value === void 0) {
        return this.undefinedCharacter;
      }
      switch (typeof value) {
        case 'number':
        case 'uint':
        case 'int':
        case 'float':
          return value.toString();
        case 'boolean':
          if (value) {
            return "T";
          } else {
            return "F";
          }
          break;
        case 'string':
          return this.quoteCharacter + unreserve(value);
        case 'object':
          partial = [];
          if (value instanceof Array) {
            for (_i = 0, _len = value.length; _i < _len; _i++) {
              v = value[_i];
              partial.push(this.convertToString(v));
            }
            enclosures = {
              start: this.containerCharacters.arrayBegin,
              stop: this.containerCharacters.arrayEnd
            };
          } else {
            for (k in value) {
              v = value[k];
              partial.push(this.convertToString(v));
            }
            enclosures = {
              start: this.containerCharacters.objectBegin,
              stop: this.containerCharacters.objectEnd
            };
          }
          return enclosures.start + partial.join(this.separatorCharacters.skip0) + enclosures.stop;
        default:
          return String(value);
      }
    };

    printSchema = function(schema, tab, prefix) {
      var i, p, v, _i, _len;
      if (tab == null) {
        tab = "";
      }
      if (prefix == null) {
        prefix = "";
      }
      if (Array.isArray(schema)) {
        console.log(prefix + "[" + tab);
        for (i = _i = 0, _len = schema.length; _i < _len; i = ++_i) {
          v = schema[i];
          if (typeof v === 'object' || Array.isArray(v)) {
            printSchema(v, tab + "    ", tab + "[" + i + "]=");
          } else {
            console.log(tab + "[" + i + "]=" + v);
          }
        }
        return console.log("]" + tab);
      } else if (typeof schema === 'object') {
        console.log(prefix + "{" + tab);
        for (p in schema) {
          v = schema[p];
          if (typeof v === 'object' || Array.isArray(v)) {
            printSchema(v, tab + "    ", p + ": ");
          } else {
            console.log(tab + p + ": " + v);
          }
        }
        return console.log("}" + tab);
      } else {
        return console.log(tab + "value:" + schema);
      }
    };

    translate = function(value) {
      switch (value) {
        case 'uint':
        case 'int':
        case 'float':
          return 'number';
        default:
          return value;
      }
    };

    makeSchema = function(schema) {
      var i, p, result, v, _i, _len;
      result = [];
      if (Array.isArray(schema)) {
        result.push("");
        for (i = _i = 0, _len = schema.length; _i < _len; i = ++_i) {
          v = schema[i];
          if (typeof v === 'object' || Array.isArray(v)) {
            result.push(makeSchema(v));
          } else {
            result.push(translate(v));
          }
          break;
        }
      } else if (typeof schema === 'object') {
        for (p in schema) {
          v = schema[p];
          result.push(p);
          if (typeof v === 'object' || Array.isArray(v)) {
            result.push(makeSchema(v));
          } else {
            result.push(translate(v));
          }
        }
      } else {
        result.push(translate(schema));
      }
      return result;
    };

    IOTON.prototype.parse = function(text, schema) {
      var end, falseHextet, findEnd, i, indexStack, j, makeArrayValue, makeBoolean, makeContainerValueInArray, makeContainerValueInObject, makeObjectValue, makeString, makeTyped, makeValue, nullHextet, objects, pop, push, quoteHextet, separator, set, setArray, setObject, split, splitCharacter, stack, start, token, tokens, top, trueHextet, undefinedHextet, _i, _len, _ref, _ref1, _ref2;
      if (schema == null) {
        schema = null;
      }
      if (schema) {
        this.schema(schema);
      }
      schema = this.parser_schema;
      stack = new Stack();
      indexStack = new Stack();
      splitCharacter = this.separatorCharacters.skip0;
      quoteHextet = this.quoteHextet;
      trueHextet = this.trueHextet;
      falseHextet = this.falseHextet;
      nullHextet = this.nullHextet;
      undefinedHextet = this.undefinedHextet;
      split = function(buffer, characters) {
        var i, separator, tempBuffer, tempString, tokens, _i, _ref, _ref1;
        tokens = [];
        separator = splitCharacter;
        tempString = "" + separator;
        for (i = _i = 0, _ref = buffer.length; _i < _ref; i = _i += 1) {
          if ((_ref1 = buffer[i], __indexOf.call(characters, _ref1) >= 0)) {
            tempBuffer = new Buffer(tempString, this.encoding);
            tokens.push(tempBuffer);
            separator = String.fromCharCode(buffer[i]);
            tempString = "" + separator;
          } else {
            tempString += String.fromCharCode(buffer[i]);
          }
        }
        tempBuffer = new Buffer(tempString, this.encoding);
        tokens.push(tempBuffer);
        return tokens;
      };
      push = function(value, type, index) {
        var keys;
        if (index == null) {
          index = null;
        }
        keys = null;
        if (indexStack.isEmpty()) {
          keys = schema;
        } else {
          if (type === "object") {
            keys = (stack.peek().schema)[(indexStack.peek()) * 2 + 1];
          } else {
            if ((indexStack.peek()) * 2 + 1 < stack.peek().schema.length) {
              keys = stack.peek().schema[(indexStack.peek()) * 2 + 1];
            } else {
              keys = stack.peek().schema;
            }
            if (typeof keys === "string") {
              keys = stack.peek().schema;
            }
          }
        }
        indexStack.push(index);
        return stack.push({
          value: value,
          type: type,
          schema: keys
        });
      };
      pop = function() {
        var top;
        top = stack.pop();
        indexStack.pop();
        return top;
      };
      makeBoolean = function(value) {
        switch (value[0]) {
          case trueHextet:
            return true;
          case falseHextet:
            return false;
          default:
            return null;
        }
      };
      makeString = function(value) {
        if (value[0] === quoteHextet) {
          return value.toString().substring(1);
        }
        return value.toString();
      };
      makeTyped = function(value) {
        switch (value[0]) {
          case nullHextet:
            return null;
          case undefinedHextet:
            return void 0;
          case trueHextet:
          case falseHextet:
            return makeBoolean(value);
          case quoteHextet:
            return makeString(value);
          default:
            return number(value);
        }
      };
      makeValue = function(value, type, tag) {
        if (value[0] === nullHextet) {
          return null;
        }
        if (value[0] === undefinedHextet) {
          return void 0;
        }
        switch (type) {
          case "string":
            return makeString(value);
          case 'number':
          case 'uint':
          case 'int':
          case 'float':
            return number(value);
          case "boolean":
            return makeBoolean(value);
          case "dynamic":
            return makeTyped(value);
          default:
            return makeTyped(value);
        }
      };
      makeContainerValueInObject = function(value) {
        var index, tag, type;
        index = indexStack.pop();
        tag = stack.peek().schema[index * 2];
        type = stack.peek().schema[index * 2 + 1];
        index++;
        stack.peek().value[tag] = value;
        return indexStack.push(index);
      };
      makeObjectValue = function(value) {
        var index, tag, type;
        if (value == null) {
          value = null;
        }
        index = indexStack.pop();
        tag = stack.peek().schema[index * 2];
        type = stack.peek().schema[index * 2 + 1];
        index++;
        value = makeValue(value, type, tag);
        stack.peek().value[tag] = value;
        return indexStack.push(index);
      };
      setObject = function(value, separator) {
        if (!(value instanceof Buffer) && (Array.isArray(value) || typeof value === 'object')) {
          return makeContainerValueInObject(value);
        } else {
          return makeObjectValue(value);
        }
      };
      makeContainerValueInArray = function(value) {
        var tag, type;
        tag = stack.peek().schema[0];
        type = stack.peek().schema[1];
        return stack.peek().value.push(value);
      };
      makeArrayValue = function(value) {
        var tag, type;
        tag = stack.peek().schema[0];
        type = stack.peek().schema[1];
        if (tag !== "") {
          console.log("have tag in array! : " + tag + "  from: " + stack.peek().schema);
        }
        value = makeValue(value, type, tag);
        return stack.peek().value.push(value);
      };
      setArray = function(value, separator) {
        if (!(value instanceof Buffer) && (Array.isArray(value) || typeof value === 'object')) {
          return makeContainerValueInArray(value);
        } else {
          return makeArrayValue(value);
        }
      };
      set = function(value) {
        var top;
        if (!stack.isEmpty()) {
          top = stack.peek();
          if (top.type === "object") {
            return setObject(value, null);
          } else {
            return setArray(value, null);
          }
        }
      };
      findEnd = (function(_this) {
        return function(token, i) {
          var j;
          j = i;
          while (i < token.length && token[i] !== _this.containerCharacters.arrayEnd.charCodeAt(0) && token[i] !== _this.containerCharacters.objectEnd.charCodeAt(0)) {
            i++;
          }
          return [j, i - 1, i];
        };
      })(this);
      objects = null;
      tokens = split(text, this.separators);
      if (tokens[1] === void 0) {
        return makeTyped(text);
      }
      j = 0;
      for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        i = 0;
        while (i < token.length) {
          if (_ref = token[i], __indexOf.call(this.separators, _ref) >= 0) {
            separator = token[i];
            i++;
          }
          if (token[i] === this.containerCharacters.objectBegin.charCodeAt(0)) {
            push({}, "object", 0, {});
            i++;
          } else if (token[i] === this.containerCharacters.objectEnd.charCodeAt(0)) {
            top = pop();
            objects = top.value;
            set(objects);
            i++;
          } else if (token[i] === this.containerCharacters.arrayBegin.charCodeAt(0)) {
            push([], "array", 0, []);
            i++;
          } else if (token[i] === this.containerCharacters.arrayEnd.charCodeAt(0)) {
            top = pop();
            objects = top.value;
            set(objects);
            i++;
          } else {
            top = stack.peek();
            if (top.type === "object") {
              _ref1 = findEnd(token, i), start = _ref1[0], end = _ref1[1], i = _ref1[2];
              setObject(token.slice(start, +end + 1 || 9e9), separator);
            } else {
              _ref2 = findEnd(token, i), start = _ref2[0], end = _ref2[1], i = _ref2[2];
              setArray(token.slice(start, +end + 1 || 9e9), separator);
            }
          }
        }
      }
      return objects;
    };

    convertToJavascript = function(text) {
      var obj;
      obj = eval('(' + sanatize(text.toString()) + ')');
      return obj;
    };

    IOTON.prototype.JSON = function(iotonStr, schema) {
      var object;
      if (schema == null) {
        schema = null;
      }
      if (schema) {
        this.schema(schema);
      }
      object = this.parse(iotonStr);
      return JSON.stringify(object);
    };

    IOTON.prototype.IOTON = function(jsonStr, schema) {
      var object;
      if (schema == null) {
        schema = null;
      }
      if (schema) {
        this.schema(schema);
      }
      object = JSON.parse(jsonStr);
      return this.stringify(object);
    };

    unreserve = function(text) {
      return text.replace(/[\u0000-\u0006|\u000E-\u0010|\u0012|\u0014-\u001A|\u001C-\u001F]/g, '');
    };

    sanatize = function(text) {
      return text;
    };

    IOTON.prototype.uncontrol = function(ioton) {
      var i, text, _i, _ref, _results;
      text = new Buffer(ioton);
      _results = [];
      for (i = _i = 0, _ref = text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (text[i] === 0x01) {
          _results.push(text[i] = 0x7B);
        } else if (text[i] === 0x02) {
          _results.push(text[i] = 0x5B);
        } else if (text[i] === 0x03) {
          _results.push(text[i] = 0x5D);
        } else if (text[i] === 0x04) {
          _results.push(text[i] = 0x7D);
        } else if (text[i] === 0x0E) {
          _results.push(text[i] = 0x7D);
        } else if (text[i] === 0x0F) {
          _results.push(text[i] = 0x22);
        } else if (text[i] === 0x1A) {
          _results.push(text[i] = 0x2C);
        } else if (text[i] === 0x1C) {
          _results.push(text[i] = 0x2C);
        } else if (text[i] === 0x1D) {
          _results.push(text[i] = 0x2C);
        } else if (text[i] === 0x1E) {
          _results.push(text[i] = 0x2C);
        } else if (text[i] === 0x1F) {
          _results.push(text[i] = 0x2C);
        } else if (text[i] === 0x19) {
          _results.push(text[i] = 0x40);
        } else if (text[i] === 0x16) {
          _results.push(text[i] = 0x3F);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    number = function(value) {
      var str;
      str = value.toString();
      if (~str.indexOf('.')) {
        return parseFloat(str);
      } else {
        return parseInt(str);
      }
    };

    IOTON.prototype.makeObject = function(object, schema, maker) {
      var i, property, tmp, value, _i;
      if (maker == null) {
        maker = 0;
      }
      if (schema === 'number' || schema === 'uint' || schema === 'int' || schema === 'float') {
        return maker++;
      } else if (schema === 'boolean') {
        return maker % 2 === 0;
      } else if (schema === 'string') {
        return (maker++).toString();
      } else if (typeof schema === 'object') {
        if (schema instanceof Array) {
          tmp = [];
          for (i = _i = 0; _i <= 2; i = ++_i) {
            tmp.push(this.makeObject({}, schema[0]));
          }
          return tmp;
        } else {
          for (property in schema) {
            value = schema[property];
            object[property] = this.makeObject({}, value);
          }
        }
      }
      return object;
    };

    IOTON.prototype.make = function(schema) {
      var object;
      if (schema == null) {
        schema = null;
      }
      if (schema) {
        this.schema(schema);
      }
      object = this.makeObject({}, this._schema);
      return object;
    };

    IOTON.prototype.makeify = function() {
      var object;
      object = this.make();
      return this.stringify(object);
    };

    return IOTON;

  })();

}).call(this);

//# sourceMappingURL=ioton.js.map
